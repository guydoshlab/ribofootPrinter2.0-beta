from Bio import SeqIO
from Bio import Seq
import csv
import sys
import pickle
import gzip
import os

### This is the builddense function for creating rocc files.
# fasta_in is the longnames fasta (described elsewhere) with transcriptome information and annotation.
# sam_in is the output of your aligner (typically bowtie1).
# outfile is the name of the rocc file you are creating (without extension).
# normalize determines how you want the read values normalized. Put -1 for normalize to use all reads to compute rpm. Alternatively, put in total reads to divide by or 1E6 for no normalization.
# Smallsize and largesize are the limits (inclusive) of which read sizes to include.
# endmode should be set to 0 if doing coverage (for example mRNA-Seq) where end information is not desired. Set to 1 (default) for 5' ends or -1 for 3' ends.
def main(fasta_in,sam_in,outfile,normalize,smallsize,largesize,endmode):
	print("\nName of python script:",(__file__.split("/")[-1]))
	print("Total arguments passed:", len(locals()))
	print("Argument names: "+("; ".join(list(locals().keys()))))
	argkeys=list(locals().keys())
	argvals=[]
	for key in argkeys:
		argvals.append((locals()[key]))
	print("Argument values: "+("; ".join(argvals))+"\n")
	
	normalize=int(normalize)
	smallsize=int(smallsize)
	largesize=int(largesize)
	endmode=int(endmode)	
	
	outputdata={}               # Creates an empty dictionary for storing outputdata.
	negativestrandreads=0       # Counter set to 0 to keep track of number of reads mapping to the negative strand. Reads mapping to the negative strand are not included in the outputdata dictionary.
	fsam=open(sam_in)           # Opening the SAM file generated by bowtie which contains information for each read aligned against the transcriptome.
	samgen=csv.reader(fsam,delimiter='	')  # Reading the tab-separated SAM file. The variable samgen is a list containing read alignment information.
	mappedreads={}              # Creates an empty dictionary for storing mappedreads. 
	mappedreads["all"]=0	    # Adding an entry "all" with count set to 0.
	#for readlen in list(range(smallsize,largesize+1)):      # Not needed; keeping for future options. Looping over the set size cutoff to populate mappedreads dictionary with spaceholder 0s.
	#	mappedreads[readlen]=0
	
	# Adding in transcripts information from the transcriptome FASTA file into outputdata dictionary (serving as a basic lookup table to obtain metadata for each gene)
	for record in SeqIO.parse(fasta_in, "fasta"):       # Reading in a fasta file using the SeqIO package.
		gene=record.id.split("|")[0]                    # Obtains genename from fasta file (ENSG000000001.12).
		outputdata[gene]=["alias","sequence",{},"ORFstart","utr3start","transcriptlen"] #  Generates a list with 6 placeholders 
		outputdata[gene][0]=record.id.split("|")[5]	                    # Alias name of gene
		outputdata[gene][1]=str(record.seq)	                            # Sequence of transcript
		outputdata[gene][3]=(record.id.split("|")[7]).split("-")[-1]	# ORF start
		outputdata[gene][4]=(record.id.split("|")[8]).split("-")[-1]	# UTR3 start
		outputdata[gene][5]=record.id.split("|")[6]	                    # Transcript length
		genelength=int(outputdata[gene][5])
		#print(record.id) # Troubleshooting errors in FASTA file. This will determine which entry gives the error.
		#for readlen in list(range(smallsize,largesize+1)):	# Option to put in for readsize specific work.
		#	outputdata[gene][2][str(readlen)+"_5"]=[0 for x in range(genelength)] # Put back for readsize specific work future possible upgrade.
		#	outputdata[gene][2][str(readlen)+"_3"]=[0 for x in range(genelength)] # Put back for readsize specific work future possible upgrade.

		if endmode == 0:
			outputdata[gene][2]["cov"]=[0 for x in range(genelength)]     # Populating dictionary for endmode mapping reads with the same number of 0s as genelength
		elif endmode==1:
			outputdata[gene][2]["all_5"]=[0 for x in range(genelength)]     # Populating dictionary for 5' end mapping reads with the same number of 0s as genelength
		elif endmode==-1:
			outputdata[gene][2]["all_3"]=[0 for x in range(genelength)]     # Populating dictionary for 3' end mapping reads with the same number of 0s as genelength

	print("Sequences added.")
	
	paired=0
	# Loop through the samfile.
	for read in samgen:
		if read[0][0] == '@':   # Ignore header lines.
			continue
		
		# Note the lines below are not required and are not exhaustive (i.e. codes for one read mapped and one unmapped are not here); any other unmapped reads are eliminated below when checking for mapped reads.
		if read[1] == '4':      # A bowtie no match.  Single end.
			continue
		if read[1] == '141':      # both reads unmapped. Paired end. 1+4+8+128
			continue
		if read[1] == '77':      # both reads unmapped. Paired end. 1+4+8+64
			continue
			
		# Remove negative strands
		if (read[1] == '16'):		# single end
			negativestrandreads+=1
			continue
		if (read[1] == '99' or read[1] == '147'):	# flag is 99/147 (64+32+1+2/128+16+1+2) for paired end. 
			negativestrandreads+=1/float(2)
			continue
		
		# Determine if a matching read and if paired end or single end.
		# Flag is # 64+16+1+2 (paired end) and 128+32+1+2 (paired end). Note Illumina TruSeq kit specifies this in the manual. Single end 0.
		goodread=0
		if (read[1] == '0'):
			goodread=1
		elif (read[1] == '163' or read[1] == '83'):
			goodread=2	
			paired=1	

		gene = read[2]              # gene name for mapped bowtie read
		startp = int(read[3]) - 1   # start position. Need to subtract 1 since genomic sequence starts at 1, but list structures for read summing start at 0.
		seq = Seq.Seq(read[9])      # sequence of the read
		length = len(seq)           # length of read
		if (length<smallsize or length > largesize):
			continue

		# Note that paired end reads are included if both map and each read gets a half count in the total. For coverage, read density is spread out over the read's length.
		# Note that it would be possible to store counts data as a simple list and not a dictionary with 1 key. However, the dictionary enables potential future options.
		if (goodread>0):		
			if endmode == 0:
				for i in range(startp, startp+length):
					outputdata[gene][2]["cov"][i]+=1/(float(length))
			elif endmode == 1:
				outputdata[gene][2]["all_5"][startp]+=1
			elif endmode == -1:
				outputdata[gene][2]["all_3"][startp+length-1]+=1
			if goodread==2:
				mappedreads["all"]+=1/float(2)	# Allows 0.5 read for paired end to be added since the pair together is 1 read.
			else:
				mappedreads["all"]+=1			
				
	print(str(mappedreads["all"])+" reads mapped to transcriptome.")
	print(str(negativestrandreads)+" negative reads mapped to transcriptome.")
	if paired==1:
		print("Detected paired end reads.")
		if endmode!=0:
			print("Warning: not using coverage with paired end reads. This is not recommended.")	
		
	# Normalize
	genecount=0
	if normalize==-1:
		for gene in outputdata.keys():
			genecount+=1
			if genecount%5000==0 or genecount==1:
				print("Genes normalized="+str(genecount))
			for key in (outputdata[gene][2]).keys():
				
				if normalize==-1:
					outputdata[gene][2][key]=(normalizelist(outputdata[gene][2][key],(mappedreads["all"]/float(1E6))))			
				else:
					outputdata[gene][2][key]=(normalizelist(outputdata[gene][2][key],(normalize/float(1E6))))
	print("Genes normalized="+str(genecount))
	
	# Create info key with an info dictionary. This is for metadata and gets popped out during loading.
	if endmode == 0:
		endmode="cov"
	elif endmode == 1:
		endmode= "all_5"
	elif endmode == -1:
		endmode = "all_3"
	outputdata["info"]={}	
	outputdata["info"]["mappedreads"]=mappedreads["all"]
	outputdata["info"]["endmode"]=[endmode]	# Use a list for future upgradeability.
	
	# Pickle the dictionary
	f = gzip.open(outfile+'.rocc', 'wb') # Create rocc file.
	pickle.dump(outputdata,f)
	f.close()
	fsam.close()

	
def normalizelist(listin,normfactor):
	newlist=[]
	for element in listin:
		newlist.append(element/float(normfactor))	
	return newlist

# For running from the command line, the code below pulls in the variables and calls main.
# Alternatively, a separate python caller script can call main. 
if __name__ == "__main__":
	if len(sys.argv)!=8:
		print("Wrong number of inputs.")
		exit()
	main(sys.argv[1],sys.argv[2],sys.argv[3],sys.argv[4],sys.argv[5],sys.argv[6],sys.argv[7])

